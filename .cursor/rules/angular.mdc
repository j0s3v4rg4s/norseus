---
description:
globs: *.ts,*html
alwaysApply: false
---
# Angular Project Standards

This project utilizes **Angular 19** and adheres strictly to its latest standards and best practices. All development should follow the guidelines outlined in the official @Angular Style Guide.

## Key Principles:

### 1. Standalone Components, Directives, and Pipes
   - **Do** leverage the standalone API introduced in Angular 14 and finalized later. All new components, directives, and pipes should be standalone by default. since v19 is not necesarry to set standalone: true inside `@Component` decorator, it is by default in true
   - **Why?** Simplifies the mental model by removing the need for `NgModule`, reduces boilerplate, and improves tree-shakability. It aligns with the modern Angular ecosystem direction.

### 2. Single Responsibility Principle (SRP)
   - **Do** define one logical thing (component, service, directive, pipe) per file.
   - **Consider** limiting files to around 400 lines of code.
   - **Why?** Enhances readability, maintainability, testability, and reduces source control collisions. Avoids hidden bugs from shared variables or unwanted coupling.

### 3. Naming Conventions
   - **Do** use consistent names following the `feature.type.ts` pattern (e.g., `user-profile.component.ts`, `auth.service.ts`, `validation.directive.ts`).
   - **Do** use dashes (`-`) to separate words in the descriptive name (e.g., `user-profile`).
   - **Do** use dots (`.`) to separate the name from the type (e.g., `component.ts`).
   - **Why?** Provides a consistent way to identify file content quickly and understand its purpose.

### 4. Component Design
   - **Do** create components with separate files for the template (`.html`), styles (`.scss`), and component logic (`.ts`). Inline templates and styles should only be used for very minimal components (e.g., 1-3 lines).
   - **Why?** Separation improves organization, readability, and allows designers/developers to work on template/styles without interfering with component logic.
   - **Do** prefer using the `inject()` function within the component class body or constructor for dependency injection instead of constructor parameter injection.
   - **Why?** `inject()` offers more flexibility, especially in inheritance scenarios and when used within reusable functions or base classes. It aligns with the direction of functional utilities in Angular.
   - **Do** use Signals for state management within components where appropriate, especially for reactive scenarios replacing complex RxJS chains. Refer to @Angular Signals Guide.
   - **Do** utilize signal-based inputs (`input()`) and model inputs (`model()`) over decorator-based `@Input()` where applicable, especially for new components.
   - **Do** prefer using signal-based outputs (`output()`) over decorator-based `@Output()` with `EventEmitter` for new components.
   - **Why?** Signal-based inputs and outputs provide better type safety, are more composable, and integrate seamlessly with Angular's reactivity model based on Signals.
   - **Do** keep components lean. Delegate complex logic to services.
   - **Do** implement lifecycle hook interfaces (`OnInit`, `OnDestroy`, etc.) for type safety and clarity. See @Lifecycle Hooks.
   - **Why?** Promotes reusability, testability, and clear separation of concerns. Signals offer a fine-grained reactivity model and integrate well with the modern Angular features like signal inputs/outputs.

### 5. Directives
   - **Do** use attribute directives for behavior/presentation logic without a template (e.g., `[myHighlight]`).
   - **Do** use structural directives (`*`) when manipulating the DOM structure (e.g., `*ngIf`, `*ngFor`, custom structural directives).
   - **Consider** preferring `@HostListener` and `@HostBinding` over the `host` metadata property in decorators for clarity and easier modification.
   - **Why?** Clear separation of concerns between modifying element behavior/appearance and modifying DOM structure. `@HostListener`/`@HostBinding` keep related logic together. See @Attribute Directives and @Structural Directives.

### 6. Services
   - **Do** provide services using `@Injectable({ providedIn: 'root' })`.
   - **Why?** Creates singleton instances shared across the application and enables better tree-shaking by build optimizers.
   - **Do** refactor data operations (HTTP calls, local storage, state management logic) into dedicated services. Components should consume services, not handle data fetching directly.
   - **Why?** Decouples components from data sources, improves testability (mocks), and centralizes data logic.

### 7. Styling
   - **Do** scope styles to components using view encapsulation (default).
   - **Consider** using CSS Custom Properties (variables) for themeable components.

### 8. Template Control Flow
   - **Do** use Angular's built-in control flow syntax (`@if`, `@for`, `@switch`) in component templates instead of the older structural directives (`*ngIf`, `*ngFor`, `*ngSwitch`). See @Control Flow Guide.
   - **Do** use `@if`, `@else if`, and `@else` for conditional rendering.
     ```html
     @if (userLoggedIn) {
       <span>Welcome, {{ userName }}!</span>
     } @else if (isLoading) {
       <span>Loading...</span>
     } @else {
       <button>Log In</button>
     }
     ```

   - **Do** use `@switch`, `@case`, and `@default` for multi-way conditional rendering (similar to JavaScript `switch`).
     ```html
     @switch (accessLevel) {
       @case ('admin') {
         <app-admin-panel />
       }
       @case ('editor') {
         <app-editor-tools />
       }
       @default {
         <app-viewer-mode />
       }
     }
     ```

   - **Do** use `@for` for iterating over collections. **Crucially**, always include a `track` expression (`@for (item of items; track item.id)`) to optimize performance by helping Angular identify items.
   - **Do** utilize the `@empty` block with `@for` to display content when the collection is empty.
     ```html
     <ul>
       @for (user of users; track user.id; let idx = $index, f = $first) {
         <li [class.first]="f">User {{ idx + 1 }}: {{ user.name }}</li>
       } @empty {
         <li>No users found.</li>
       }
     </ul>
     ```
     *(Note: `track` is vital for performance. Use a unique property like `item.id`. If none exists, consider adding one. `$index` can be used for static lists, but avoid it for dynamic data if possible.)*

   - **Why?** The built-in control flow offers a more ergonomic and JavaScript-aligned syntax, potentially improves type checking within templates, and the `track` requirement in `@for` is essential for rendering performance.

### 9. Template Variables
   - **Do** utilize Angular's template variable features (`@let` and `#var`) to store and reference values directly within the template. See @Template Variables Guide.

   **Local Template Variables (`@let`)**
   - **Do** use `@let` to declare local, read-only variables within a template block, based on expressions.
   - **Why?** Simplifies complex templates by storing intermediate results or aliasing expressions, improving readability and maintainability. Angular keeps the value updated automatically.
     ```html
     @let fullName = user.firstName + ' ' + user.lastName;
     @let cartValue = cartItems$ | async;

     <h1>Welcome, {{ fullName }}!</h1>

     @if (cartValue) {
       <p>Cart Total: {{ cartValue | currency }}</p>
       @if (cartValue > 100) {
         <p>Free shipping!</p>
       }
     }
     ```
   - **Note:** `@let` variables are scoped to their view block and descendants; they cannot be reassigned.

   **Template Reference Variables (`#var`)**
   - **Do** use template reference variables (`#variableName`) to get a reference to a DOM element, component instance, directive instance (via `exportAs`), or `TemplateRef` within the template.
   - **Why?** Allows interaction between different parts of the template (e.g., reading an input's value, accessing a child component's methods) or querying elements from the component class.
     ```html
     <!-- Reference an input element -->
     <input #nameInput placeholder="Enter name" (keyup.enter)="submit(nameInput.value)">
     <button (click)="nameInput.focus()">Focus Name</button>

     <!-- Reference a component instance -->
     <app-video-player #player />
     <button (click)="player.play()">Play Video</button>

     <!-- Reference a directive instance -->
     <div myCustomTooltip="Help text" #tooltip="myCustomTooltip">
       Hover me
     </div>
     <button (click)="tooltip.show()">Show Tooltip</button>
     ```

### 10. Modules
   - While standalone is the default, `NgModule` might still be used for organizing routing configurations (`provideRouter`), providing groups of services, or for libraries not yet migrated to standalone APIs. Use them judiciously.

